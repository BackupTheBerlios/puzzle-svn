<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Puzzle.SyntaxDocument</name>
    </assembly>
    <members>
        <member name="T:Puzzle.SourceCode.BlockType">
             <summary>
             BlockType class
             </summary>
             <remarks>
             The BlockType class represents a specific code/text element<br/>
             such as a string , comment or the code itself.<br/>
             <br/>
             a BlockType  can contain keywords , operators , scopes and child BlockTypes.<br/>
             <br/>
             <br/>
             For example , if we where to describe the language C#<br/>
             we would have the following blocks:<br/>
             <br/>
             Code block						- the BlockType containing all the keywords and operators.<br/>
             Singleline comment block		- a BlockType that starts on // terminates at the end of a line.<br/>
             Multiline comment block			- a BlockType that starts on /* can span multiple rows and terminates on */.<br/>
             String block					- a BlockType that starts on " terminates on " or at the end of a line.<br/>
             Char block						- a BlockType that starts on ' terminates on ' or at the end of a line.<br/>
             <br/>
             <b>CHILD BLOCKS:</b><br/>
             The code block would have all the other blocks as childblocks , since they can only appear inside the<br/>
             code block . A string can for example never exist inside a comment in C#.<br/>
             a BlockType can also have itself as a child block.<br/>
             For example , the C# Code block can have itself as a childblock and use the scope patterns "{" and "}"<br/>
             this way we can accomplish FOLDING since the parser will know where a new scope starts and ends.<br/>
             <br/>
             <b>SCOPES:</b><br/>
             Scopes describe what patterns starts and what patterns end a specific BlockType.<br/>
             For example , the C# Multiline Comment have the scope patterns /* and */<br/>
             <br/>
             <b>KEYWORDS:</b><br/>
             A Keyword is a pattern that can only exist between separator chars.<br/>
             For example the keyword "for" in c# is valid if it is contained in this string " for ("<br/>
             but it is not valid if the containing string is " MyFormat "<br/>
             <br/>
             <b>OPERATORS:</b><br/>
             Operators is the same thing as keywords but are valid even if there are no separator chars around it.<br/>
             In most cases operators are only one or two chars such as ":" or "->"<br/>
             operators in this context should not be mixed up with code operators such as "and" or "xor" in VB6<br/>
             in this context they are keywords.<br/>
            <br/>
             <br/>
            </remarks>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.KeywordsList">
            <summary>
            A list of keyword groups.
            For example , one keyword group could be "keywords" and another could be "datatypes"
            theese groups could have different color shemes assigned to them.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.OperatorsList">
            <summary>
            A list of operator groups.
            Each operator group can contain its own operator patterns and its own color shemes.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.ScopePatterns">
            <summary>
            A list of scopes , most block only contain one scope , eg a scope with start and end patterns "/*" and "*/"
            for multiline comments, but in some cases you will need more scopes , eg. PHP uses both "&lt;?" , "?&gt;" and "&lt;?PHP" , "PHP?&gt;"
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.ChildBlocks">
            <summary>
            A list containing which BlockTypes are valid child blocks in a specific block.
            eg. strings and comments are child blocks for a code block
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.Style">
            <summary>
            The style to use when colorizing the content of a block,
            meaning everything in this block except keywords , operators and childblocks.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.Name">
            <summary>
            The name of this block.
            names are not required for block but can be a good help when interacting with the parser.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.BackColor">
            <summary>
            The background color of a block.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.MultiLine">
            <summary>
            Gets or Sets if the BlockType can span multiple lines or if it should terminate at the end of a line.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.BlockType.TerminateChildren">
            <summary>
            Gets or Sets if the parser should terminate any child block when it finds an end scope pattern for this block.
            for example %&gt; in asp terminates any asp block even if it appears inside an asp string.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.BlockType.#ctor(Puzzle.SourceCode.Language)">
            <summary>
            Default BlockType constructor
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.BlockType.Transparent">
            <summary>
            Returns false if any color has been assigned to the backcolor property
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.BlockTypeCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.#ctor(Puzzle.SourceCode.BlockTypeCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.#ctor(Puzzle.SourceCode.BlockType[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.CopyTo(Puzzle.SourceCode.BlockType[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.CopyTo(Puzzle.SourceCode.BlockType[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Add(Puzzle.SourceCode.BlockType)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Contains(Puzzle.SourceCode.BlockType)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.IndexOf(Puzzle.SourceCode.BlockType)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Insert(System.Int32,Puzzle.SourceCode.BlockType)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Remove(Puzzle.SourceCode.BlockType)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.AddRange(Puzzle.SourceCode.BlockTypeCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.AddRange(Puzzle.SourceCode.BlockType[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.BlockTypeCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.BlockTypeCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.BlockTypeCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.BlockTypeCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.BlockTypeCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.BlockTypeCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.SyntaxDocumentExporters.HTMLExporter">
            <summary>
            Html exporter class
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentExporters.HTMLExporter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentExporters.HTMLExporter.Export(Puzzle.SourceCode.SyntaxDocument,System.String)">
            <summary>
            Exports the content of a SyntaxDocument to a HTML formatted string
            </summary>
            <param name="doc">SyntaxDocument object to export from</param>
            <param name="ImagePath">File path tho the images to use in the HTML string</param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentExporters.HTMLExporter.Export(Puzzle.SourceCode.SyntaxDocument,System.Drawing.Color,System.String,System.String)">
            <summary>
            Exports the content of a SyntaxDocument to a HTML formatted string
            </summary>
            <param name="doc">SyntaxDocument object to export from</param>
            <param name="BGColor">HTML color string to use as background color</param>
            <param name="ImagePath">File path tho the images to use in the HTML string</param>
            <param name="Style">HTML style string that should be applied to the output</param>
            <returns></returns>
        </member>
        <member name="T:Puzzle.SourceCode.FormatRange">
            <summary>
            Format ranges can be applied to a syntaxdocument to mark sections such as breakpoints or errors
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.FileType">
            <summary>
            File type struct
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.FileType.Extension">
            <summary>
            The file type extension
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.FileType.Name">
            <summary>
            The name of the file type
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.Language">
            <summary>
            The Language class describes a language.<br/>
            It consists of a MainBlock , which is the start BlockType of the Language<br/>
            It also have a list of filetypes that is valid for this language<br/>
            </summary>
            <example>
            <b>Apply a Syntax to a SyntaxBox</b>
            <code>
            SyntaxBoxControl1.Document.SyntaxFile="C#.syn";
            </code>
            </example>
        </member>
        <member name="F:Puzzle.SourceCode.Language.Name">
            <summary>
            Name of the Language
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Language.MainBlock">
            <summary>
            The start BlockType for this language
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Language.FileTypes">
            <summary>
            ArrayList containing the valid filetypes for this language
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Language.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Language.Blocks">
            <summary>
            Gets all BlockTypes in a given language.
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.LanguageList">
            <summary>
            Language list class
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.LanguageList.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.LanguageList.GetLanguageFromFile(System.String)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.LanguageList.ListLanguages">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Puzzle.SourceCode.SyntaxLoader">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxLoader.Load(System.String)">
            <summary>
            Load a specific language file
            </summary>
            <param name="File">File name</param>
            <returns>Language object</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxLoader.Load(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="File"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxLoader.LoadXML(System.String)">
            <summary>
            Load a specific language from an xml string
            </summary>
            <param name="XML"></param>
            <returns></returns>
        </member>
        <member name="T:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.SyntaxDocumentParsers.IParser">
            <summary>
            Parser interface.
            Implement this interface if you want to create your own parser.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.Init(System.String)">
            <summary>
            Initializes the parser with a spcified SyntaxFile
            </summary>
            <param name="SyntaxFile">Filename of the SyntaxFile that should be used</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.Init(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="SyntaxFile"></param>
            <param name="Separators"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.Init(Puzzle.SourceCode.Language)">
            <summary>
            Initializes the parser with a spcified Language object
            </summary>
            <param name="Language">The Language object to assign to the parser</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.ParseLine(System.Int32,System.Boolean)">
            <summary>
            Called by the SyntaxDocument object when a row should be parsed
            </summary>
            <param name="RowIndex">The row index in the document</param>
            <param name="ParseKeywords">true if keywords and operators should be parsed , false if only a segment parse should be performed</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.ParsePreviewLine(System.Int32)">
            <summary>
            Called by the SyntaxDocument object when a row must be preview parsed.
            </summary>
            <param name="RowIndex">Row index in the document</param>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.Document">
            <summary>
            Gets or Sets the Document object for this parser
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocumentParsers.IParser.Language">
            <summary>
            Gets or Sets the Language for this parser
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.Init(System.String)">
            <summary>
            
            </summary>
            <param name="SyntaxFile"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.Init(Puzzle.SourceCode.Language)">
            <summary>
            
            </summary>
            <param name="Language"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.ParsePreviewLine(System.Int32)">
            <summary>
            
            </summary>
            <param name="RowIndex"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.ParseLine(System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="ParseKeywords"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.Language">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocumentParsers.DefaultParser.Document">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.PatternScanResult">
            <summary>
            PatternScanResult struct is redurned by the Pattern class when an .IndexIn call has been performed.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternScanResult.Index">
            <summary>
            The index on which the pattern was found in the source string
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternScanResult.Token">
            <summary>
            The string that was found , this is always the same as the pattern StringPattern property if the pattern is a simple pattern.
            if the pattern is complex this field will contain the string that was found by the scan.
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.Pattern">
            <summary>
            A Pattern is a specific string or a RegEx pattern that is used by the parser.
            There are two types of patterns , Simple and Complex.
            
            Simple Patterns are patterns that consists of a simple fixed string eg. "void" or "for".
            Complex Patterns are patterns that consists of RegEx patterns , eg hex numbers or urls can be described as regex patterns.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Pattern.Category">
            <summary>
            Category of the pattern
            Built in categories are:
            URL
            MAIL
            FILE
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Pattern.LowerStringPattern">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Pattern.IsComplex">
            <summary>
            Gets if the pattern is a simple string or a RegEx pattern
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Pattern.IsSeparator">
            <summary>
            Gets or Sets if the pattern is a separator pattern .
            A separator pattern can be "End Sub" in VB6 , whenever that pattern is found , the SyntaxBoxControl will render a horizontal separator line.
            NOTE: this should not be mixed up with separator chars.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Pattern.IsKeyword">
            <summary>
            Get or Sets if this pattern needs separator chars before and after it in order to be valid.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Pattern.Parent">
            <summary>
            The owning PatternList , eg a specific KeywordList or OperatorList
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Pattern.#ctor(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pattern"></param>
            <param name="iscomplex"></param>
        </member>
        <member name="M:Puzzle.SourceCode.Pattern.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pattern"></param>
            <param name="iscomplex"></param>
            <param name="separator"></param>
            <param name="keyword"></param>
        </member>
        <member name="M:Puzzle.SourceCode.Pattern.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="pattern"></param>
            <param name="iscomplex"></param>
            <param name="separator"></param>
            <param name="keyword"></param>
            <param name="EscapeChar"></param>
        </member>
        <member name="M:Puzzle.SourceCode.Pattern.HasSeparators(System.String,System.Int32)">
            <summary>
            For public use only
            </summary>
            <param name="Text"></param>
            <param name="Position"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Pattern.IndexIn(System.String,System.Int32,System.Boolean,System.String)">
            <summary>
            Returns the index of the pattern in a string
            </summary>
            <param name="Text">The string in which to find the pattern</param>
            <param name="StartPosition">Start index in the string</param>
            <param name="MatchCase">true if a case sensitive match should be performed</param>
            <returns>A PatternScanResult containing information on where the pattern was found and also the text of the pattern</returns>
        </member>
        <member name="P:Puzzle.SourceCode.Pattern.StringPattern">
            <summary>
            Gets or Sets the the text of the pattern
            this only applies if the pattern is a simple pattern.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Pattern.ContainsSeparator">
            <summary>
            Returns true if the pattern contains separator chars<br/>
            (This is used by the parser)
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.PatternCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.#ctor(Puzzle.SourceCode.PatternCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.#ctor(Puzzle.SourceCode.Pattern[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.CopyTo(Puzzle.SourceCode.Pattern[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.CopyTo(Puzzle.SourceCode.Pattern[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Add(Puzzle.SourceCode.Pattern)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Contains(Puzzle.SourceCode.Pattern)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.IndexOf(Puzzle.SourceCode.Pattern)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Insert(System.Int32,Puzzle.SourceCode.Pattern)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Remove(Puzzle.SourceCode.Pattern)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.AddRange(Puzzle.SourceCode.PatternCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.AddRange(Puzzle.SourceCode.Pattern[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.PatternCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.PatternCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.PatternCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.PatternCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.PatternCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.PatternList">
            <summary>
            A List containing patterns.
            this could be for example a list of keywords or operators
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.SimplePatterns">
            <summary>
            for public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.SimplePatterns1Char">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.SimplePatterns2Char">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.ComplexPatterns">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.Style">
            <summary>
            Gets or Sets the TextStyle that should be assigned to patterns in this list
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.CaseSensitive">
            <summary>
            Gets or Sets if this list contains case seinsitive patterns
            </summary>		
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.NormalizeCase">
            <summary>
            Gets or Sets if the patterns in this list should be case normalized
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.ParentBlock">
            <summary>
            The parent BlockType of this list
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternList.Name">
            <summary>
            The name of the pattern list
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternList.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternList.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternList.Add(Puzzle.SourceCode.Pattern)">
            <summary>
            
            </summary>
            <param name="Pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternList.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.PatternListList">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternListList.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternListList.IsKeyword">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.PatternListList.IsOperator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternListList.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.PatternListList.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternListList.Add(Puzzle.SourceCode.PatternList)">
            <summary>
            
            </summary>
            <param name="Group"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.PatternListList.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.PatternListList.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.SourceCodePrintDocument">
            <summary>
            Printer document class.
            </summary>
            <example >
            
            
            <b>Print the content of a SyntaxDocument:</b>
            <code>
            SourceCodePrintDocument PrintDoc=new SourceCodePrintDocument(MySyntaxDocument);
            
            PrintDialog1.Document =PrintDoc;
            if (PrintDialog1.ShowDialog ()==DialogResult.OK)
            	PrintDoc.Print ();
            </code>
            <hr/>
            <b>Print Preview the content of a SyntaxDocument</b>
            <code>
            SourceCodePrintDocument PrintDoc=new SourceCodePrintDocument(MySyntaxDocument);
            PrintPreviewDialog1.Document = PrintDoc
            PrintPreviewDialog1.ShowDialog ();
            </code>
            </example>
        </member>
        <member name="T:Puzzle.SourceCode.RowState">
            <summary>
            Parser state of a row
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.RowState.NotParsed">
            <summary>
            the row is not parsed
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.RowState.SegmentParsed">
            <summary>
            the row is segment parsed
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.RowState.AllParsed">
            <summary>
            the row is both segment and keyword parsed
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.Row">
            <summary>
            The row class represents a row in a SyntaxDocument
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.StartSegments">
            <summary>
            Segments that start on this row
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.EndSegments">
            <summary>
            Segments that ends in this row
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Document">
            <summary>
            The owner document
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.StartSegment">
            <summary>
            The first collapsable segment on this row.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.EndSegment">
            <summary>
            The first segment that terminates on this row.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Expansion_StartSegment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Expansion_EndSegment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Images">
            <summary>
            Collection of Image indices assigned to a row.
            </summary>
            <example>
            <b>Add an image to the current row.</b>
            <code>
            MySyntaxBox.Caret.CurrentRow.Images.Add(3);
            </code>
            </example>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Tag">
            <summary>
            Object tag for storage of custom user data..
            </summary>
            <example>
            <b>Assign custom data to a row</b>
            <code>
            //custom data class
            class CustomData{
            	public int		abc=123;
            	publci string	def="abc";
            }
            
            ...
            
            //assign custom data to a row
            Row MyRow=MySyntaxBox.Caret.CurrentRow;
            CustomData MyData=new CustomData();
            MyData.abc=1337;
            MyRow.Tag=MyData;
            
            ...
            
            //read custom data from a row
            Row MyRow=MySyntaxBox.Caret.CurrentRow;
            if (MyRow.Tag != null){
            	CustomData MyData=(CustomData)MyRow.Tag;
            	if (MyData.abc==1337){
            		//Do something...
            	}
            }
            
            
            </code>
            </example>
        </member>
        <member name="F:Puzzle.SourceCode.Row.InQueue">
            <summary>
            Returns true if the row is in the owner documents parse queue
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.InKeywordQueue">
            <summary>
            Returns true if the row is in the owner documents keyword parse queue
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Indent">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Expansion_PixelStart">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Expansion_StartChar">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Expansion_PixelEnd">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Row.Expansion_EndChar">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Row.EnsureVisible">
            <summary>
            If the row is hidden inside a collapsed segment , call this method to make the collapsed segments expanded.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Row.AddToParseQueue">
            <summary>
            Adds this row to the parse queue
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Row.SetText(System.String)">
            <summary>
            Assigns a new text to the row.
            </summary>
            <param name="Text"></param>
        </member>
        <member name="M:Puzzle.SourceCode.Row.MatchCase">
            <summary>
            Call this method to make all words match the case of their patterns.
            (this only applies if the row is fully parsed)
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Row.GetEnumerator">
            <summary>
            Get the Word enumerator for this row
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.Parse">
            <summary>
            Force a segment parse on the row.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Row.Parse(System.Boolean)">
            <summary>
            Forces the parser to parse this row directly
            </summary>
            <param name="ParseKeywords">true if keywords and operators should be parsed</param>
        </member>
        <member name="M:Puzzle.SourceCode.Row.GetLeadingWhitespace">
            <summary>
            Returns the whitespace string at the begining of this row.
            </summary>
            <returns>a string containing the whitespace at the begining of this row</returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.Add(Puzzle.SourceCode.Word)">
            <summary>
            Adds a word object to this row
            </summary>
            <param name="word">Word object</param>
        </member>
        <member name="M:Puzzle.SourceCode.Row.IndexOf(Puzzle.SourceCode.Word)">
            <summary>
            Returns the index of a specific Word object
            </summary>
            <param name="word">Word object to find</param>
            <returns>index of the word in the row</returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindRightWordByPatternList(Puzzle.SourceCode.PatternList,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="PatternList"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindRightWordByPatternListName(System.String,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="PatternListName"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindLeftWordByPatternList(Puzzle.SourceCode.PatternList,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="PatternList"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindLeftWordByPatternListName(System.String,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="PatternListName"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindLeftWordByBlockType(Puzzle.SourceCode.BlockType,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="BlockType"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindRightWordByBlockType(Puzzle.SourceCode.BlockType,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="BlockType"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindLeftWordByBlockTypeName(System.String,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="BlockTypeName"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.Row.FindRightWordByBlockTypeName(System.String,Puzzle.SourceCode.Word,System.Boolean)">
            <summary>
            For public use only
            </summary>
            <param name="BlockTypeName"></param>
            <param name="StartWord"></param>
            <param name="IgnoreStartWord"></param>
            <returns></returns>
        </member>
        <member name="P:Puzzle.SourceCode.Row.RowState">
            <summary>
            The parse state of this row
            </summary>
            <example>
            <b>Test if the current row is fully parsed.</b>
            <code>
            if (MySyntaxBox.Caret.CurrentRow.RowState==RowState.AllParsed)
            {
            	//do something
            }
            </code>
            </example>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Bookmarked">
            <summary>
            Gets or Sets if this row has a bookmark or not.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Breakpoint">
            <summary>
            Gets or Sets if this row has a breakpoint or not.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Count">
            <summary>
            Returns the number of words in the row.
            (this only applied if the row is fully parsed)
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Text">
            <summary>
            Gets or Sets the text of the row.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Item(System.Int32)">
            <summary>
            Return the Word object at the specified index.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Index">
            <summary>
            Returns the index of this row in the owner SyntaxDocument.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.VisibleIndex">
            <summary>
            Returns the visible index of this row in the owner SyntaxDocument
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.NextVisibleRow">
            <summary>
            Returns the next visible row.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.NextRow">
            <summary>
            Returns the next row
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.PrevVisibleRow">
            <summary>
            Returns the first visible row before this row.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.IsCollapsed">
            <summary>
            Returns true if the row is collapsed
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.IsCollapsedEndPart">
            <summary>
            Returns true if this row is the last part of a collepsed segment
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.CanFold">
            <summary>
            Returns true if this row can fold
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Expanded">
            <summary>
            Gets or Sets if this row is expanded.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.CanFoldEndPart">
            <summary>
            Returns true if this row is the end part of a collapsable segment
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.HasExpansionLine">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Expansion_EndRow">
            <summary>
            Returns the last row of a collapsable segment
            (this only applies if this row is the start row of the segment)
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.Expansion_StartRow">
            <summary>
            Returns the first row of a collapsable segment
            (this only applies if this row is the last row of the segment)
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.VirtualCollapsedRow">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.CollapsedText">
            <summary>
            Returns the text that should be displayed if the row is collapsed.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Row.PrevRow">
            <summary>
            Returns the row before this row.
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.RowCollection">
            <summary>
            Row collection class.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.#ctor(Puzzle.SourceCode.RowCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.#ctor(Puzzle.SourceCode.Row[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.CopyTo(Puzzle.SourceCode.Row[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.CopyTo(Puzzle.SourceCode.Row[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Add(Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Contains(Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.IndexOf(Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Insert(System.Int32,Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Remove(Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.AddRange(Puzzle.SourceCode.RowCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.AddRange(Puzzle.SourceCode.Row[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.RowCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.RowCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.RowCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.RowCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.RowCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.RowCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.Scope">
            <summary>
            The Scope class defines what patterns starts and ends a BlockType
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.Start">
            <summary>
            The Start trigger Pattern
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.SpawnBlockOnStart">
            <summary>
            BlockType that should be started directly after this block have started
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.SpawnBlockOnEnd">
            <summary>
            BlockType that should be started directly after this block have ended
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.Parent">
            <summary>
            The owner BlockType
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.EndPatterns">
            <summary>
            List of end patterns
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.Style">
            <summary>
            The style that should be applied to the start and end patterns
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.ExpansionText">
            <summary>
            The text that should be displayed if the owner block is collapsed
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.DefaultExpanded">
            <summary>
            Gets or Sets if this block should be expanded or collapsed by default
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.CaseSensitive">
            <summary>
            Gets or Sets if the scope patterns is case sensitive
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Scope.NormalizeCase">
            <summary>
            Gets or Sets if the scope patterns should be case normalized
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Scope.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.ScopeCollection">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.ScopeCollection.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.#ctor(Puzzle.SourceCode.BlockType)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.#ctor(Puzzle.SourceCode.ScopeCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.#ctor(Puzzle.SourceCode.Scope[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.CopyTo(Puzzle.SourceCode.Scope[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.CopyTo(Puzzle.SourceCode.Scope[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Add(Puzzle.SourceCode.Scope)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Contains(Puzzle.SourceCode.Scope)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.IndexOf(Puzzle.SourceCode.Scope)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Insert(System.Int32,Puzzle.SourceCode.Scope)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Remove(Puzzle.SourceCode.Scope)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.AddRange(Puzzle.SourceCode.ScopeCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.AddRange(Puzzle.SourceCode.Scope[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.ScopeCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.ScopeCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.ScopeCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.ScopeCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ScopeCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.ScopeCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.Segment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.BlockType">
            <summary>
            The owner BlockType
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.Parent">
            <summary>
            The parent segment
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.Depth">
            <summary>
            The depth of this segment in the segment hirarchy
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.StartRow">
            <summary>
            The row on which the segment starts
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.StartWord">
            <summary>
            The word that starts this segment
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.EndRow">
            <summary>
            The row that the segment ends on
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.EndWord">
            <summary>
            The word that ends this segment
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.Expanded">
            <summary>
            Gets or Sets if this segment is expanded
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Segment.Scope">
            <summary>
            Gets or Sets what scope triggered this segment
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Segment.#ctor(Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="startrow"></param>
        </member>
        <member name="M:Puzzle.SourceCode.Segment.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.SegmentCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.#ctor(Puzzle.SourceCode.SegmentCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.#ctor(Puzzle.SourceCode.Segment[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.CopyTo(Puzzle.SourceCode.Segment[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.CopyTo(Puzzle.SourceCode.Segment[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Add(Puzzle.SourceCode.Segment)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Contains(Puzzle.SourceCode.Segment)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.IndexOf(Puzzle.SourceCode.Segment)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Insert(System.Int32,Puzzle.SourceCode.Segment)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Remove(Puzzle.SourceCode.Segment)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.AddRange(Puzzle.SourceCode.SegmentCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.AddRange(Puzzle.SourceCode.Segment[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.SegmentCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SegmentCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SegmentCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.SegmentCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SegmentCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SegmentCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.TextStyle">
            <summary>
            TextStyles are used to describe the apperance of text.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyle.Name">
            <summary>
            Name of the style
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyle._Bold">
            <summary>
            Gets or Sets if the style uses a Bold font
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyle._Italic">
            <summary>
            Gets or Sets if the style uses an Italic font
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyle._Underline">
            <summary>
            Gets or Sets if the style uses an Underlined font
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyle._ForeColor">
            <summary>
            Gets or Sets the ForeColor of the style
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyle._BackColor">
            <summary>
            Gets or Sets the BackColor of the style
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.TextStyle.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.TextStyle.Transparent">
            <summary>
            Returns true if no color have been assigned to the backcolor
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.TextStyleDesignerDialog">
            <summary>
            Summary description for TextStyleDesignerDialog.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextStyleDesignerDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.TextStyleDesignerDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.TextStyleDesignerDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.UndoAction">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.UndoAction.InsertRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.UndoAction.DeleteRange">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.UndoBlock">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.UndoBlock.Text">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.UndoBlock.Position">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.UndoBlock.Action">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.UndoBlockCollection">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.UndoBlockCollection.Name">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.#ctor(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.#ctor(Puzzle.SourceCode.UndoBlock[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.CopyTo(Puzzle.SourceCode.UndoBlock[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.CopyTo(Puzzle.SourceCode.UndoBlock[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Add(Puzzle.SourceCode.UndoBlock)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Contains(Puzzle.SourceCode.UndoBlock)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.IndexOf(Puzzle.SourceCode.UndoBlock)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Insert(System.Int32,Puzzle.SourceCode.UndoBlock)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Remove(Puzzle.SourceCode.UndoBlock)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.AddRange(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.AddRange(Puzzle.SourceCode.UndoBlock[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBlockCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBlockCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBlockCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.UndoBlockCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBlockCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBlockCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.UndoBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.#ctor(Puzzle.SourceCode.UndoBuffer)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.#ctor(Puzzle.SourceCode.UndoBlockCollection[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.RemoveRange(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.ClearFrom(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.CopyTo(Puzzle.SourceCode.UndoBlockCollection[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.CopyTo(Puzzle.SourceCode.UndoBlockCollection[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Add(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Contains(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.IndexOf(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Insert(System.Int32,Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Remove(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.AddRange(Puzzle.SourceCode.UndoBuffer)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.AddRange(Puzzle.SourceCode.UndoBlockCollection[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBuffer.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBuffer.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBuffer.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.UndoBuffer.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.UndoBuffer.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.UndoBuffer.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.WordType">
            <summary>
            Word types
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.WordType.xtWord">
            <summary>
            The word is a normal word/text
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.WordType.xtSpace">
            <summary>
            The word is a space char
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.WordType.xtTab">
            <summary>
            The word is a tab char
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.Word">
            <summary>
            The word object class represents a word in a Row object
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.Row">
            <summary>
            The parent row
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.Segment">
            <summary>
            The parent segment
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.Type">
            <summary>
            The type of the word
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.Pattern">
            <summary>
            The pattern that created this word
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.Text">
            <summary>
            The text of the word
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.Style">
            <summary>
            The style of the word
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.ErrorColor">
            <summary>
            Color of the error wave lines
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.HasError">
            <summary>
            True if the word has error wave lines
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.Word.InfoTip">
            <summary>
            The ToolTip text for the word
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.Word.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Word.Index">
            <summary>
            Gets the index of the word in the parent row
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.Word.Column">
            <summary>
            Returns the column where the word starts on the containing row.
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.WordCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.#ctor(Puzzle.SourceCode.WordCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.#ctor(Puzzle.SourceCode.Word[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.CopyTo(Puzzle.SourceCode.Word[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.CopyTo(Puzzle.SourceCode.Word[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="start"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Add(Puzzle.SourceCode.Word)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Contains(Puzzle.SourceCode.Word)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.IndexOf(Puzzle.SourceCode.Word)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Insert(System.Int32,Puzzle.SourceCode.Word)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Remove(Puzzle.SourceCode.Word)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.AddRange(Puzzle.SourceCode.WordCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.AddRange(Puzzle.SourceCode.Word[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.WordCollection.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.WordCollection.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.WordCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.WordCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.WordCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.WordCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.ImageIndexCollection">
            <summary>
            Collection of Ts
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.#ctor(Puzzle.SourceCode.ImageIndexCollection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.#ctor(System.Int32[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.CopyTo(System.Int32[])">
            <summary>
            Copies this list into another KeyboardrActionList
            </summary>
            <param name="array">Target list</param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.CopyTo(System.Int32[],System.Int32)">
            <summary>
            Copies this list into another KeyboardrActionList
            </summary>
            <param name="array">Target list</param>
            <param name="start">Start index</param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Add(System.Int32)">
            <summary>
            Adds a T to the list
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Clear">
            <summary>
            Removes all Ts from the list
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Contains(System.Int32)">
            <summary>
            Returns true if the list contains the specified Int
            </summary>
            <param name="item">T to find</param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.IndexOf(System.Int32)">
            <summary>
            Returns the index of a specified T
            </summary>
            <param name="item">T to find</param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Insert(System.Int32,System.Int32)">
            <summary>
            Inserts a Int at a specified position
            </summary>
            <param name="position">Insert position</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Remove(System.Int32)">
            <summary>
            Remove a specified item from the list
            </summary>
            <param name="item">Item to remove</param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specified index
            </summary>
            <param name="index">Index to remove at</param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.GetEnumerator">
            <summary>
            Gets the ImageIndexCollection Enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Clone">
            <summary>
            Clones the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.AddRange(Puzzle.SourceCode.ImageIndexCollection)">
            <summary>
            Add the content of another TList to this list
            </summary>
            <param name="collection">List to copy items from</param>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.AddRange(System.Int32[])">
            <summary>
            Add the content of a Int array to this list
            </summary>
            <param name="array"></param>
        </member>
        <member name="P:Puzzle.SourceCode.ImageIndexCollection.Count">
            <summary>
            Returns the T count in this list
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.ImageIndexCollection.Item(System.Int32)">
            <summary>
            Returns the T at the specified index
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.ImageIndexCollection.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.ImageIndexCollection.Enumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Enumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.ImageIndexCollection.Enumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.ImageIndexCollection.Enumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.TextPoint">
            <summary>
            Class representing a point in a text.
            where x is the column and y is the row.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.TextPoint.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.TextPoint.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
        </member>
        <member name="E:Puzzle.SourceCode.TextPoint.Change">
            <summary>
            Event fired when the X or Y property has changed.
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.TextPoint.X">
            <summary>
            
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.TextPoint.Y">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.RowEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.RowEventArgs.#ctor(Puzzle.SourceCode.Row)">
            <summary>
            
            </summary>
            <param name="row"></param>
        </member>
        <member name="F:Puzzle.SourceCode.RowEventArgs.Row">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.ParserEventHandler">
            <summary>
            Parser event handler
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.RowEventHandler">
            <summary>
            
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.SyntaxDocument">
            <summary>
            The SyntaxDocument is a component that is responsible for Parsing , Folding , Undo / Redo actions and various text actions.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.ParseQueue">
            <summary>
            List of rows that should be parsed
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.KeywordQueue">
            <summary>
            
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.VisibleRows">
            <summary>
            List of rows that is not hidden by folding
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.UndoBuffer">
            <summary>
            Buffer containing undo actions
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.Parser">
            <summary>
            The active parser of the document
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.mIsParsed">
            <summary>
            For public use only
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.Tag">
            <summary>
            Tag property , lets the user store custom data in the row.
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.SyntaxDocument.NeedResetRows">
            <summary>
            Gets or Sets if folding needs to be recalculated
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ChangeVersion">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.StartUndoCapture">
            <summary>
            Starts an Undo Capture.
            This method can be called if you with to collect multiple text operations into one undo action
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.EndUndoCapture">
            <summary>
            Ends an Undo capture and pushes the collected actions onto the undostack
            <seealso cref="M:Puzzle.SourceCode.SyntaxDocument.StartUndoCapture"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ReParse">
            <summary>
            ReParses the document
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ClearBookmarks">
            <summary>
            Removes all bookmarks in the document
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ClearBreakpoints">
            <summary>
            Removes all breakpoints in the document.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.EnsureParsed(Puzzle.SourceCode.Row)">
            <summary>
            Call this method to ensure that a specific row is fully parsed
            </summary>
            <param name="Row"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.#ctor(System.ComponentModel.IContainer)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.InvokeChange">
            <summary>
            Call this method to make the SyntaxDocument raise the Changed event
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ParseAll">
            <summary>
            Performs a segment parse on all rows. No Keyword colorizing
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ParseAll(System.Boolean)">
            <summary>
            Parses all rows , either a segment parse or a full parse with keyword colorizing
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.FoldAll">
            <summary>
            Folds all foldable rows
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.UnFoldAll">
            <summary>
            UnFolds all foldable rows
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ParseSome">
            <summary>
            Parses a chunk of 1000 rows , this is not thread safe
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ParseSome(System.Int32)">
            <summary>
            Parse a chunk of rows, this is not thread safe
            </summary>
            <param name="RowCount">The number of rows to parse</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Add(System.String)">
            <summary>
            Add a new row with the specified text to the bottom of the document
            </summary>
            <param name="Text">Text to add</param>
            <returns>The row that was added</returns>		
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Add(System.String,System.Boolean)">
            <summary>
            Add a new row with the specified text to the bottom of the document
            </summary>
            <param name="Text">Text to add</param>
            <param name="StoreUndo">true if and undo action should be added to the undo stack</param>
            <returns>The row that was added</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Insert(System.String,System.Int32)">
            <summary>
            Insert a text at the specified row index
            </summary>
            <param name="Text">Text to insert</param>
            <param name="index">Row index where the text should be inserted</param>
            <returns>The row that was inserted</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Insert(System.String,System.Int32,System.Boolean)">
            <summary>
            Insert a text at the specified row index
            </summary>
            <param name="Text">Text to insert</param>
            <param name="index">Row index where the text should be inserted</param>
            <param name="StoreUndo">true if and undo action should be added to the undo stack</param>
            <returns>The row that was inserted</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Remove(System.Int32)">
            <summary>
            Remove a row at specified row index
            </summary>
            <param name="index">index of the row that should be removed</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Remove(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Remove a row at specified row index
            </summary>
            <param name="index">index of the row that should be removed</param>
            <param name="StoreUndo">true if and undo action should be added to the undo stack</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.DeleteRange(Puzzle.SourceCode.TextRange)">
            <summary>
            Deletes a range of text
            </summary>
            <param name="Range">the range that should be deleted</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ParseRow(Puzzle.SourceCode.Row,System.Boolean)">
            <summary>
            Forces a row to be parsed
            </summary>
            <param name="r">Row to parse</param>
            <param name="ParseKeywords">true if keywords and operators should be parsed</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ParseRow(Puzzle.SourceCode.Row)">
            <summary>
            Forces a row to be parsed
            </summary>
            <param name="r">Row to parse</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetNextBookmark(System.Int32)">
            <summary>
            Gets the row index of the next bookmarked row
            </summary>
            <param name="StartIndex">Start index</param>
            <returns>Index of the next bookmarked row</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetPreviousBookmark(System.Int32)">
            <summary>
            Gets the row index of the previous bookmarked row
            </summary>
            <param name="StartIndex">Start index</param>
            <returns>Index of the previous bookmarked row</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.DeleteRange(Puzzle.SourceCode.TextRange,System.Boolean)">
            <summary>
            Deletes a range of text
            </summary>
            <param name="Range">Range to delete</param>
            <param name="StoreUndo">true if the actions should be pushed onto the undo stack</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetRange(Puzzle.SourceCode.TextRange)">
            <summary>
            Get a range of text
            </summary>
            <param name="Range">The range to get</param>
            <returns>string containing the text inside the given range</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.IndexOf(Puzzle.SourceCode.Row)">
            <summary>
            Returns the index of a given row
            </summary>
            <param name="xtr">row to find</param>
            <returns>Index of the given row</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.clear">
            <summary>
            Clear all content in the document
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.InsertText(System.String,System.Int32,System.Int32)">
            <summary>
            Inserts a text into the document at a given column,row.
            </summary>
            <param name="text">Text to insert</param>
            <param name="xPos">Column</param>
            <param name="yPos">Row index</param>
            <returns>TextPoint containing the end of the inserted text</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.InsertText(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Inserts a text into the document at a given column,row.
            </summary>
            <param name="text">Text to insert</param>
            <param name="xPos">Column</param>
            <param name="yPos">Row index</param>
            <param name="StoreUndo">true if this action should be pushed onto the undo stack</param>
            <returns>TextPoint containing the end of the inserted text</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetRangeFromText(System.String,System.Int32,System.Int32)">
            <summary>
            Gets a Range from a given text
            </summary>
            <param name="text"></param>
            <param name="xPos"></param>
            <param name="yPos"></param>
            <returns></returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.AddToUndoList(Puzzle.SourceCode.UndoBlockCollection)">
            <summary>
            Add an action to the undo stack
            </summary>
            <param name="ActionGroup">action to add</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Undo">
            <summary>
            Perform an undo action
            </summary>
            <returns>The position where the caret should be placed</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetSegmentFromPos(Puzzle.SourceCode.TextPoint)">
            <summary>
            Gets a Segment object form a given column , Row index
            (This only applies if the row is fully parsed)
            </summary>
            <param name="p">Column and Rowindex</param>
            <returns>Segment object at the given position</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetWordFromPos(Puzzle.SourceCode.TextPoint)">
            <summary>
            Gets a Word object form a given column , Row index
            (this only applies if the row is fully parsed)
            </summary>
            <param name="p">Column and Rowindex</param>
            <returns>Word object at the given position</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.GetFormatWordFromPos(Puzzle.SourceCode.TextPoint)">
            <summary>
            Gets a Word object form a given column , Row index
            (this only applies if the row is fully parsed)
            </summary>
            <param name="p">Column and Rowindex</param>
            <returns>Word object at the given position</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.InvokeRowParsed(Puzzle.SourceCode.Row)">
            <summary>
            Call this method to make the document raise the RowParsed event
            </summary>
            <param name="row"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ResetVisibleRows">
            <summary>
            Call this method to recalculate the visible rows
            </summary>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.PointToIntPos(Puzzle.SourceCode.TextPoint)">
            <summary>
            Converts a Column/Row index position into a char index
            </summary>
            <param name="pos">TextPoint where x is column and y is row index</param>
            <returns>Char index in the document text</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.IntPosToPoint(System.Int32)">
            <summary>
            Converts a char index into a Column/Row index
            </summary>
            <param name="pos">Char index to convert</param>
            <returns>Point where x is column and y is row index</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ToggleRow(Puzzle.SourceCode.Row)">
            <summary>
            Toggle expansion of a given row
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.CollapseRow(Puzzle.SourceCode.Row)">
            <summary>
            Collapse a given row
            </summary>
            <param name="r">Row to collapse</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.ExpandRow(Puzzle.SourceCode.Row)">
            <summary>
            Expand a given row
            </summary>
            <param name="r">Row to expand</param>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Redo">
            <summary>
            Perform an redo action
            </summary>
            <returns>The position where the caret should be placed</returns>
        </member>
        <member name="M:Puzzle.SourceCode.SyntaxDocument.Finalize">
            <summary>
            
            </summary>
        </member>
        <member name="E:Puzzle.SourceCode.SyntaxDocument.ParsingCompleted">
            <summary>
            Event that is raised when there is no more rows to parse
            </summary>
        </member>
        <member name="E:Puzzle.SourceCode.SyntaxDocument.Parsing">
            <summary>
            Raised when the parser is active
            </summary>
        </member>
        <member name="E:Puzzle.SourceCode.SyntaxDocument.Change">
            <summary>
            Raised when the document content is changed
            </summary>
        </member>
        <member name="E:Puzzle.SourceCode.SyntaxDocument.ModifiedChanged">
            <summary>
            Raised when the modified flag has changed
            </summary>
        </member>
        <member name="E:Puzzle.SourceCode.SyntaxDocument.RowParsed">
            <summary>
            Raised when a row have been parsed
            </summary>
        </member>
        <member name="E:Puzzle.SourceCode.SyntaxDocument.RowDeleted">
            <summary>
            Raised when a row have been deleted
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.MaxUndoBufferSize">
            <summary>
            Gets or Sets the Maximum number of entries in the undobuffer
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.Modified">
            <summary>
            Get or Set the Modified flag
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.SyntaxFile">
            <summary>
            Get or Set the Name of the Syntaxfile to use
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.Folding">
            <summary>
            Gets or Sets if the document should use folding or not
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.IsParsed">
            <summary>
            Gets if the document is fully parsed
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.Item(System.Int32)">
            <summary>
            Returns the row at the specified index
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.Count">
            <summary>
            Gets the row count of the document
            </summary>
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.Text">
            <summary>
            Gets or Sets the text of the entire document
            </summary>		
        </member>
        <member name="P:Puzzle.SourceCode.SyntaxDocument.Lines">
            <summary>
            Gets and string array containing the text of all rows.
            </summary>
        </member>
        <member name="T:Puzzle.SourceCode.TextRange">
            <summary>
            A range of text
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextRange._FirstRow">
            <summary>
            The start row of the range
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextRange._FirstColumn">
            <summary>
            The start column of the range
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextRange._LastRow">
            <summary>
            The end row of the range
            </summary>
        </member>
        <member name="F:Puzzle.SourceCode.TextRange._LastColumn">
            <summary>
            The end column of the range
            </summary>
        </member>
    </members>
</doc>
